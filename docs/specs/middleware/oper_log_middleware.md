# Spec: OperLog Middleware

This document outlines the specification for the `OperLogMiddleware`, a Gin middleware responsible for recording details of user operations.

## 1. Functional Requirements

1.  **Operation Logging**: The middleware must intercept incoming requests and outgoing responses to log detailed information about the operation.
2.  **Configurability**: The middleware must be initializable with a specific `title` (describing the operation module, e.g., "User Management") and `businessType` (e.g., Create, Update, Delete).
3.  **Data Capture**: The middleware must capture the following information for each request:
    *   **Module Title**: The `title` provided during initialization.
    *   **Business Type**: The `businessType` integer code provided.
    *   **Handler Method**: The Go method name of the final handler (e.g., `mira/app/controller/system.(*UserController).GetUserList-fm`).
    *   **HTTP Method**: The request's HTTP method (e.g., `GET`, `POST`).
    *   **Operator Info**: The operator's nickname and department name, retrieved from the security context. If the user is not authenticated, these fields should be empty.
    *   **Request URL**: The full path of the request URL.
    *   **Operator IP & Location**: The client's IP address and its geographical location.
    *   **Request Parameters**: A JSON string containing a combination of the request body and URL query parameters.
    *   **Response Data**: The full JSON body of the response.
    *   **Operation Status**: `NORMAL` (1) for successful operations (HTTP 200) and `EXCEPTION` (2) for failures.
    *   **Error Message**: If the operation status is `EXCEPTION`, this field should contain the error message from the response body.
    *   **Timestamps**: The time the operation occurred and the total processing time in milliseconds.
4.  **Request Body Handling**: The middleware must read the request body for logging purposes without preventing the downstream handlers from reading it.
5.  **Response Body Interception**: The middleware must capture the response body generated by the downstream handlers to log it.
6.  **Persistence**: The captured log data must be assembled into a `SaveOperLogRequest` DTO and passed to the `OperLogService` for persistence.

## 2. Edge Cases

1.  **Unauthenticated Access**: If no user is authenticated, `OperName` and `DeptName` should be logged as empty strings, and the process should continue normally.
2.  **Non-JSON Response**: If the response body is not valid JSON, the `JsonResult` will be logged as is, but parsing for the `ErrorMsg` might fail, resulting in an empty error message.
3.  **Request without Body**: If the request has no body (e.g., a `GET` request), the `OperParam` should only contain the URL query parameters.
4.  **Service Failure**: The middleware does not currently handle failures during the call to `CreateSysOperLog`. The log might be lost if the service fails.
5.  **Downstream Panic**: The middleware does not include a `recover` block. It relies on a higher-level recovery middleware to handle panics in downstream handlers.

## 3. Constraints

1.  **Framework Dependency**: The middleware is tightly coupled with the Gin web framework.
2.  **Authentication Dependency**: Relies on `security.GetAuthUser(ctx)` to correctly resolve user information from the request context.
3.  **Service Dependency**: Depends on `service.OperLogService` to persist the final log record.
4.  **Performance**: The middleware introduces overhead by:
    *   Buffering the entire request body.
    *   Wrapping the `ResponseWriter` to buffer the entire response body.
    *   Executing a synchronous call to the `OperLogService`. This could potentially delay the response to the client.

## 4. Pseudocode

```plaintext
// File: app/middleware/oper_log_middleware.go

MODULE OperLogMiddleware

  // TDD ANCHOR: test_middleware_initialization
  FUNCTION OperLogMiddleware(title: STRING, businessType: INTEGER) -> HandlerFunction
    RETURN FUNCTION(context)
      // --- Setup Phase ---

      // TDD ANCHOR: test_middleware_handles_authenticated_user
      // TDD ANCHOR: test_middleware_handles_anonymous_user
      operName <- ""
      deptName <- ""
      authUser <- security.GetAuthUser(context)
      IF authUser IS NOT NULL THEN
        operName <- authUser.NickName
        deptName <- authUser.DeptName
      END IF

      requestStartTime <- Time.Now()

      // TDD ANCHOR: test_middleware_does_not_consume_request_body
      // Cache the request body to allow multiple reads
      cachedBodyBytes <- context.GetRawData()
      context.Request.Body <- CreateNewReader(cachedBodyBytes)

      // Wrap the response writer to capture the response body
      responseWriter <- NewCustomResponseWriter(context.Writer)
      context.Writer <- responseWriter

      // --- Data Collection Phase ---

      // TDD ANCHOR: test_middleware_captures_all_request_data
      // Combine request body and query params
      params <- an empty MAP
      BindJsonBodyTo(params) // Reads from context.Request.Body

      // Restore request body for the actual handler
      context.Request.Body <- CreateNewReader(cachedBodyBytes)

      FOR key, value IN context.Request.URL.Query()
        params[key] <- value
      END FOR

      operParamJson <- ConvertToJsonString(params)

      ipInfo <- ipaddress.GetAddress(context.ClientIP)

      // --- Log Initialization ---

      sysOperLog <- CREATE SaveOperLogRequest WITH {
        Title: title,
        BusinessType: businessType,
        Method: context.HandlerName(),
        RequestMethod: context.Request.Method,
        OperName: operName,
        DeptName: deptName,
        OperUrl: context.Request.URL.Path,
        OperIp: ipInfo.Ip,
        OperLocation: ipInfo.Addr,
        OperParam: operParamJson,
        Status: CONSTANT.NORMAL_STATUS,
        OperTime: Time.Now()
      }

      // --- Execution Phase ---

      // Pass control to the next middleware or the main handler
      context.Next()

      // --- Post-Execution & Logging Phase ---

      // TDD ANCHOR: test_middleware_logs_successful_response
      // Capture response and calculate duration
      responseBodyString <- responseWriter.Body.String()
      sysOperLog.JsonResult <- responseBodyString

      // TDD ANCHOR: test_middleware_logs_error_response
      parsedResponse <- ParseJson(responseWriter.Body.Bytes())
      IF parsedResponse.Code IS NOT 200 THEN
        sysOperLog.Status <- CONSTANT.EXCEPTION_STATUS
        sysOperLog.ErrorMsg <- parsedResponse.Msg
      END IF

      // TDD ANCHOR: test_middleware_calculates_cost_time
      duration <- Time.Since(requestStartTime)
      sysOperLog.CostTime <- duration.InMilliseconds()

      // Persist the log
      // TDD ANCHOR: test_log_service_is_called_with_correct_data
      logService <- NEW OperLogService()
      logService.CreateSysOperLog(sysOperLog)

    END FUNCTION
  END FUNCTION

END MODULE
```

## 5. TDD Anchors

-   `test_middleware_initialization`: Verify that the middleware can be created with a `title` and `businessType`.
-   `test_middleware_captures_all_request_data`: Test that all required data points (IP, URL, method, params) are correctly captured in the log object.
-   `test_middleware_handles_authenticated_user`: Mock an authenticated user and verify that `OperName` and `DeptName` are correctly populated.
-   `test_middleware_handles_anonymous_user`: Run without an authenticated user and verify that `OperName` and `DeptName` are empty.
-   `test_middleware_logs_successful_response`: Simulate a downstream handler returning a 200 status code and verify the log status is `NORMAL` and the `JsonResult` is captured.
-   `test_middleware_logs_error_response`: Simulate a handler returning a non-200 status code (e.g., 400 or 500) and verify the log status is `EXCEPTION` and `ErrorMsg` is populated from the response.
-   `test_middleware_calculates_cost_time`: Check that `CostTime` is a positive integer representing the execution duration.
-   `test_middleware_does_not_consume_request_body`: Create a test handler that reads the request body and assert that it can read the body successfully after the middleware has also read it.
-   `test_log_service_is_called_with_correct_data`: Mock the `OperLogService` and verify that its `CreateSysOperLog` method is called exactly once with the fully and correctly populated `SaveOperLogRequest` object.
